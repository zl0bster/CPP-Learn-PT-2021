/*************************************************************
	Практическое занятие №3 курс С110. Рекурсивные функции.
	"Старые" потоковые функции стандартной библиотеки (printf, scanf)
	Использование структур для реализации односвязного списка

*************************************************************/
#pragma warning(disable : 4996)

#include <iostream>
#include <cstdio>
#define stop __asm nop

#include "MyList.h"
#include "Lab3_stuff.h"

void main()
{
//Задание 1:	
//Рекурсивные функции.
	//1.1.Написать рекурсивную функцию вычисления суммы первых N натуральных чисел. 
	//1.2.Написать рекурсивную функцию вычисления количества цифр 10-чного натурального числа 
	//1.3.Написать рекурсивную функцию для вывода на экран строки в обратном порядке. 
	//1.4.Написать рекурсивную функцию для вывода на экран строки в прямом (!) порядке.
	const char* st = "abcdefghijklmn";
	std::cout << count_sum_recurs(3) <<"\n";
	std::cout << count_digits_qty(8192)<<'\n';
	print_backwards(st);
	std::cout << "\n==========\n";
	print_forwards(st);
	std::cout << "\n==========\n";
	//----------------------------------------------------------------------------------------------------------
	//Задание 2:	
	//Тема "Старые" потоковые функции стандартной библиотеки (printf, scanf)

	//Задание 2.1. С помощью функции scanf сформирйуте три коэффициента: A,B,C


	//Задание 2.2. Выведите таблицу значений y=A*x*x + B*x + C  
	//при изменении x в диапазоне -2 до +2 с шагом 0.5

	print_parabolic_data(1., 1., 0);

//----------------------------------------------------------------------------------------------------------
//Задание 3:	
	//ПОДСКАЗКИ: в файле "Односвязный список (процедурный подход, подсказки)_2021.pdf" 

	//3.1. Создать односвязный список 
	//	(предпочтительный вариант с использованием структуры List),
	//содержащий  узлы с данными целого типа.
	//3.2. Разработать следующие функции:
	//1) Добавление данных в список (в начало)
	//2) Удаление из списка одного элемента с заданным значением
	// (первого, который встретился)
	//   Функция должна возвращать признак, выполнено ли удаление.
	//
	//3) Удаление из списка  всех элементов с заданным значением. 
	//   Функция должна возвращать количество удаленных элементов
	//
	//4) Печать списка, начиная с "головы" 
	//   (порядок следования элементов будет обратным порядку заполнения).
	//5) Печать списка, начиная с конца (рекурсивная функция). 
	//   (порядок следования элементов будет соответствовать порядку, 
	//	в котором заполнялся список.
	//   Подсказка: сигнатура функции может быть следующей:
		// void printList_rec(const MyList& list, Node * node); 
		//, где node- указатель на узел, с которого просматривается список
	//6) Запись текущего содержимого списка в файл 
	//7) Чтение из файла содержимого в новый пустой список.
		//Подсказка 1: для файлового ввода/вывода используйте функции fprintf и fscanf
		//			  (заголовочный файл <cstdio>
		// Подсказка 2: удобно в качестве первого данного в файле хранить количество
		//			элементов  списка
		//Подсказка 3: Если файл существует и его удалось открыть
		//if()
		//{
		//Чтение данных из файла
		//а) считали количество элементов
		//б) создали новый список
		//в) считываем данные из файла и по мере чтения записываем  их в новый список.
		// Обратите внимание, в каком порядке будут расположены элементы в новом списке
		//}
		//8) Не забудьте освободить динамическую память.
	// присваивание начальных значений полям структуры 
	//...
	//	MyList list;
	//addToHead(10, list);
	//addToHead(10, list);
	//addToHead(20, list);
	//addToHead(10, list);
	//addToHead(50, list);
	//addToHead(10, list);
	//addToHead(50, list);
	//addToHead(70, list);
	//addToHead(30, list);
	//printList(list);
	//printList_rec(list, list.pHead);
	//FILE* fout = fopen("list.txt", "w");
	//if (fout)
	//{
	//	fprintf(fout, "%d", list.)
	//}
	//removeOne(30, list);
	//printList(list);
	//removeOne(50, list);
	//printList(list);
	//addToHead(10, list);
	//addToHead(10, list);
	//addToHead(10, list);
	//removeAll(10, list);
	//printList(list);
	//printList_rec(list, list.pHead);
	////освобождение динамической памяти
	{
		using std::cout;
		const char* fileName = "list1.txt";
		for (int i = 22; i > 0; i--)
			push(i);
		print_list();
		save_list(fileName);
		for (int i = 5; i > 0; i--)
			cout << pop() << ", ";
		for (int i = 5; i > 0; i--)
			cout << pop_start() << ", ";
		print_list();
		for (int i = 8; i > 0; i--)
			push_start(i);
		print_list();
		for (int i = 5; i > 0; i--)
			cout << i+10<<' '<< remove_by_val(i+10) << ", ";
		print_list();
		clear_list();
		std::cout << "List cleared.\n";
		print_list();
		load_list(fileName);
		print_list();
		stop
	}
}
