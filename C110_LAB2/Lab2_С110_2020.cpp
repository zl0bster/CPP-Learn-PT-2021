
/*************************************************************
	Практическое занятие №2 курс С110. Функции.
	Указатели на функции

*************************************************************/
#include <iostream>
#include <tchar.h>
#include <cstdlib>

#include "../C110_LAB1/Lab1_stuff.h"
#include "../C110_LAB1/Lab1_stuff.cpp"

#include "other.h"
#include "LAB2_calc.h"
#include "LAB2_arr.h"


#define	  stop __asm nop
				
int _tmain()
//int main()
{

	//Задание 1. 
	
	//Указатели на массивы в качестве аргументов.
	//Напишите два варианта функции печати элементов
	//1. во встроенном двумерном массиве
	//int ar[N][M] = {список инициализаторов};//подумайте - как и где должны быть заданы N и M
	//Вызов функции PrintArray   может выглядеть так:
	//PrintArray(ar, ... может быть, понадобится передать еще какие-нибудь данные);  //Важно! первый параметр- имя двумерного (!) массива
	//2. в динамическом двумерном массиве (обе размерности вычисляются)
	{
		const size_t N = 4;
		const size_t M = 3;
		const size_t K = 3;
		int arr2[N][M][K];
		for (int i = 0; i < N; i++)
			for (int j = 0; j < M; j++)
				for (int k = 0; k < K; k++)
					arr2[i][j][k] = i + 1;
		print_array(&arr2[0][0][0], N, M, K);

		size_t xS = 20;
		size_t yS = 14;
		unsigned int maxVal = 30;
		size_t arr1Size = xS * yS;
		int* arr1 = new int[arr1Size];
		for (unsigned int i = 0; i < arr1Size; i++)
			arr1[i] = rand() % maxVal;
		print_array(&arr1[0], 1, yS, xS);
		delete [] arr1;
	}
/////////////////////////////////////////////////////////////////////////////
	//Задание 2.

	//Передача указателя на встроенный массив в качестве параметра функции.
			//Напишите две взаимодополняющие друг друга функции:
			//1.  ... DayOfYear(...)
			//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
			//в порядковый день года(возвращаемое значение)
			//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
			// (принимает год и порядковый день года в качестве параметров и должна сформировать
			// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)
			//Проверьте работоспособность обеих функций с помощью следующего фрагмента://В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
			//для проверки "високосности" года имеет смысл создать функцию (isLeepYear)
			//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
			//данные приведенного ниже двухмерного массива nDayTab
	//int nDayTab[2][12] = {
	//	{31,28,31,30,31,30,31,31,30,31,30,31}, //невисокосный год
	//	{31,29,31,30,31,30,31,31,30,31,30,31} };	//високосный год
	//Вызов функции DayOfYear   может выглядеть так:
	//size_t day = ..., month = ..., year = ...;
	//size_t numDay = DayOfYear(day, month, year, nDayTab);  //Важно! последний параметр- имя двумерного (!) массива
	//Проверка результата обратной функцией DayOfMonth        //Важно! последний параметр- имя двумерного (!) массива
	//...
	short day = 256, yr = 2021;
	date* date1 = count_Date_from_N_days(yr, day);
	print_date(*date1);
	std::cout << '\n' << count_day_N_from_Date(*date1) << '\t' << date1->yr<<'\n';
	stop
/////////////////////////////////////////////////////////////////////////////
	//Задание 3.

	//Задание 3а. Функции с переменным числом параметров.
	//Напишите функцию (дана заготовка VarArgs, не использующая
	// макросы), которая принимает переменное число аргументов
	// типа int и выводит на печать число принятых параметров и
	// их значения.
	// Признаком конца списка является нулевое значение.
	
	int nN1=5, nN2=11, nN3=4, nN4=7, nN5=-1;
	VarArgs(nN1,0);	
	VarArgs(0);	
	VarArgs(nN1,nN2,0);	
	VarArgs(nN1,nN2,nN3,nN4,nN5,0);	
	stop


	//Задание 3б. Модифицируйте функцию 3а с помощью макросов
	// va_start, va_arg, va_end
	VarArgs1(nN1, 0);
	VarArgs1(0);
	VarArgs1(nN1, nN2, 0);
	VarArgs1(nN1, nN2, nN3, nN4, nN5, 0);


///////////////////////////////////////////////////////////////////
	//Тема Указатели на функции

	//Задание 4. Указатель на функцию. "Калькулятор".
	//Напишите функции:
	//1)Sum - принимает два значения double и возвращает сумму
	//этих значений
	//2)Sub- принимает два значения double и возвращает разность
	//этих значений
	//3)Mul - *
	//4)Div - /
	//5)а для возведения в степень можете использовать функцию стандартной библиотеки
	//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
	//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
	//		вариантов этой функции, а Вам потребуется сформировать указатель на 
	//		double pow(double, double);

	//Предоставьте пользователю	следующую возможность:
	//пока пользователь хочет пользоваться услугами Вашего калькулятора,
	//он может вводить два значения и знак операции
	//а Вы выводите результат. Результат получаете посредством вызова
	//соответствующей Вашей функции по указателю.
	//Предусмотрите возможность ввода непредусмотренного знака операции
	{
		std::cout << "\n" << "==================" << "\n";
		char acts[] = { "+-*/%" };
		int maxVal = 20;
		size_t triesCount = 12;
		for (size_t i = 0; i < triesCount; i++)
		{
			char act = acts[rand() % (sizeof(acts) - 1)];
			int arg1 = rand() % maxVal;
			int arg2 = rand() % maxVal;
			int res = calculate(act, arg1, arg2);
			std::cout << arg1 << ' ' << act << ' ' << arg2 << " = " << res << '\n';
		}
	}
	stop
		///////////////////////////////////////////////////////////////////
			//Задание 5. Указатель на функцию в качестве аргумента.
			//Дана заготовка функции сортировки любых объектов - Sort.
			//Функция принимает следующие параметры:
			//1) указатель на первый сортируемый элемент
			//2) количество сортируемых элементов
			//3) размер элемента в байтах
			//4) указатель на функцию перестановки элементов
			//5) указатель на функцию сравнения элементов

			//5a. Напишите функцию перестановки двух целых значений -
			// SwapInt, которая принимает два void указателя и 
			//меняет значения местами

			//Напишите функцию сравнения двух целых значений -
			// CmpInt, которая принимает два void указателя и
			//возвращает int результат сравнения: 
			//<0 - первый элемент меньше, чем второй
			//=0 - равны
			//>0 - первый элемент больше, чем второй
	{
		int nAr[] = {5,17,-3,21,5,0,13,7,99,6};		//массив для сортировки
		int nTotal = sizeof(nAr) / sizeof(nAr[0]);	//количество элементов в массиве
		//Печать исходного массива
		for (int i = 0; i < nTotal; i++)
			std::cout << nAr[i] << ' ';
		std::cout << '\n';
		//Вызов сортировки
		Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), SwapInt, CmpInt);
		//Печать результатов сортировки
		for (int i = 0; i < nTotal; i++)
			std::cout << nAr[i] << ' ';
		std::cout << '\n';
	stop
	}
	
	//Задание 5б. По аналогии с 5а создайте вспомогательные
	//функции - SwapDouble и CmpDouble и вызовите функцию Sort
	//для сортировки массива вещественных значений.
	{
		float fAr[] = { 5.001,17,-3,21,5.0,0,13,7,99,6 };		//массив для сортировки
		int nTotal = sizeof(fAr) / sizeof(fAr[0]);	//количество элементов в массиве
		//Печать исходного массива
		for (int i = 0; i < nTotal; i++)
			std::cout << fAr[i] << ' ';
		std::cout << '\n';
		//Вызов сортировки
		Sort(reinterpret_cast<char*>(&fAr[0]), nTotal, sizeof(int), SwapFloat, CmpFloat);
		//Печать результатов сортировки
		for (int i = 0; i < nTotal; i++)
			std::cout << fAr[i] << ' ';
		std::cout << '\n';
		stop
	}
	
	//Задание 5в*. По аналогии с 5а создайте вспомогательные
	//функции - SwapStr и CmpStr и вызовите функцию Sort
	//для сортировки массива указателей на строки.
	{
		const char* arStr[] = { "QQQ", "SDF", "ABC","Abba", "ENFR","En" };
		int nTotal = sizeof(arStr) / sizeof(arStr[0]);
		for (int i = 0; i < nTotal; i++)
			std::cout << arStr[i] << ' ';
		std::cout << '\n';
		//Замечание:
		//в массиве линейно лежат АДРЕСА строк, надо передать АДРЕС массива,
		Sort(reinterpret_cast<char*>(&arStr[0]), nTotal, sizeof(char*), SwapStr, CmpStr);
		for (int i = 0; i < nTotal; i++)
			std::cout << arStr[i] << ' ';
		std::cout << '\n';
	}
///////////////////////////////////////////////////////////////////

//Задание 6. Массивы указателей на функцию.
	{
		//Напишите несколько функций вида
		//const char* GetString1();
		//const char* GetString2();
		//const char* GetString3();
		//const char* GetString4();
		//const char* GetString5();
		//		...., каждая из функций возвращает указатель на свою строку
		//(подумайте - какой адрес Вы имеете право возвращать из функции)
		// Вам предоставлен код этих функций.
		//Подумайте:
		//1) все ли они корректны, если нет, то как исправить некорректность
		//2) может быть требуются какие-то дополнительные действия
		//Объявите и проинициализируйте массив указателей на функции
		//GetString1,GetString2...
		//Введите номер функции, которую Вы хотите вызвать:
		typedef const char* (*CharFx)(void);
		CharFx fxArr[] =
		{
		GetString1,
		GetString2,
		GetString3,
		GetString4,
		GetString5
		};
		//Вызовите функцию
		size_t fxNum = sizeof(fxArr) / sizeof(fxArr[0]);
		for (short i = 0; i < fxNum; i++)
			std::cout << fxArr[i]() << '\n';
		//Распечатайте результат
	}
////////////////////////////////////////////////////////////////////////////
	//Задание 7*.
	//Создайте одномерный массив (размерность вычисляется в процессе
	//выполнения программы), заполните его значениями.
	//Напишите функцию, которая добавляет в массив новое значение только (!) при условии,
	//что такого значения в массиве еще нет. 
	//Подсказка: при этом размер  массива должен увеличиться!
	//Для проверки напишите функцию, которая выводит значения всех элементов на экран
///////////////////////////////////////////////////////////////////////////
	{
		using std::cout;
		int maxVal = 256;
		size_t nTries = 80;
		cout << '\n' << "+++++++++++++++++++++++" << '\n';
		init_arr();
		print_metrics();
		for (size_t i= 0; i < nTries; i++)
		{
			add_item(rand() % maxVal);
			if (i % 10 == 0) print_metrics();
		}
		for (size_t i = 0; i < get_size(); i++)
			cout << get_item(i) << ", ";
		close_arr();
	}

	return 0;
}//main

